{
	// Place your algorithm2 ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"BellmanFord": {
		"scope": "cpp",
		"prefix": "BellmanFord",
		"body": [
			"template <typename T>",
			"class BellmanFord {",
			"    struct Edge {",
			"        int to;",
			"        T cost;",
			"    };",
			"",
			"    int m_vn;                             // m_vn:=(ノード数).",
			"    std::vector<std::vector<Edge> > m_g;  // m_g[v][]:=(ノードvが始点である有向辺のリスト).",
			"    std::vector<T> m_d;                   // m_d[t]:=(ノードsからtへの最短距離).",
			"    std::vector<int> m_pre;               // m_pre[t]:=(ノードtを訪問する直前のノード番号). 逆方向経路．",
			"    T m_inf;",
			"",
			"public:",
			"    // constructor.",
			"    BellmanFord() : BellmanFord(0) {}",
			"    explicit BellmanFord(size_t vn, T inf = 1e9) : m_vn(vn), m_g(vn), m_d(vn, inf), m_pre(vn, -1), m_inf(inf) {}",
			"",
			"    // ノード数を返す．",
			"    int size() const { return m_vn; }",
			"    T infinity() const { return m_inf; }",
			"    // 重み付き有向辺を張る．",
			"    void add_edge(int from, int to, T cost) {",
			"        assert(0 <= from and from < m_vn);",
			"        assert(0 <= to and to < m_vn);",
			"        m_g[from].push_back((Edge){to, cost});",
			"    }",
			"    // グラフ全体から負閉路を検出する．O(|V|*|E|).",
			"    bool find_negative_cycle() const {",
			"        std::vector<T> nd(m_vn, 0);",
			"        for(int i = 0; i < m_vn; ++i) {",
			"            bool update = false;",
			"            for(int v = 0; v < m_vn; ++v) {",
			"                for(const Edge &e : m_g[v]) {",
			"                    if(nd[e.to] > nd[v] + e.cost) {",
			"                        nd[e.to] = nd[v] + e.cost;",
			"                        update = true;",
			"                    }",
			"                }",
			"            }",
			"            if(!update) break;",
			"            if(i == m_vn - 1) return true;  // 負閉路あり．",
			"        }",
			"        return false;",
			"    }",
			"    // ノードsから各ノードへの最短距離を求める．O(|V|*|E|).",
			"    void bellman_ford(int s) {",
			"        assert(0 <= s and s < m_vn);",
			"        std::fill(m_d.begin(), m_d.end(), m_inf);",
			"        m_d[s] = 0;",
			"        std::fill(m_pre.begin(), m_pre.end(), -1);",
			"        for(int i = 0; i < 2 * m_vn; ++i) {",
			"            bool update = false;",
			"            for(int v = 0; v < m_vn; ++v) {",
			"                if(m_d[v] == m_inf) continue;",
			"                for(const Edge &e : m_g[v]) {",
			"                    if(m_d[e.to] == -m_inf) continue;",
			"                    if(m_d[e.to] > m_d[v] + e.cost) {",
			"                        if(i < m_vn - 1) {",
			"                            m_d[e.to] = m_d[v] + e.cost;",
			"                            m_pre[e.to] = v;",
			"                        } else {",
			"                            m_d[e.to] = -m_inf;",
			"                        }",
			"                        update = true;",
			"                    }",
			"                }",
			"            }",
			"            if(!update) break;",
			"        }",
			"    }",
			"    // ノードsからtへの最短距離を返す．",
			"    T distance(int t) const {",
			"        assert(0 <= t and t < m_vn);",
			"        return m_d[t];",
			"    }",
			"    // ノードsからtへの最短経路を復元する．",
			"    std::vector<int> get_path(int t) const {",
			"        assert(0 <= t and t < m_vn);",
			"        assert(-m_inf < m_d[t] and m_d[t] < m_inf);",
			"        std::vector<int> path;",
			"        for(; t != -1; t = m_pre[t]) path.push_back(t);",
			"        std::reverse(path.begin(), path.end());",
			"        return path;",
			"    }",
			"};"
		],
		"description": "単一始点最短経路問題"
	},
	"BIT": {
		"scope": "cpp",
		"prefix": "BIT",
		"body": [
			"// Binary Indexed Tree.",
			"template <typename T>",
			"class BIT {",
			"    int sz;               // sz:=(要素数).",
			"    std::vector<T> tree;  // 1-based index.",
			"",
			"    void build() {",
			"        for(int i = 1; i < sz; ++i) {",
			"            int j = i + (i & -i);",
			"            if(j <= sz) tree[j] += tree[i];",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    BIT() : BIT(0){};",
			"    explicit BIT(size_t sz_) : sz(sz_), tree(sz_ + 1, 0) {}",
			"    explicit BIT(const std::vector<T> &v) : sz(v.size()), tree(v.size() + 1) {",
			"        std::copy(v.begin(), v.end(), tree.begin() + 1);",
			"        build();",
			"    }",
			"",
			"    int size() const { return sz; }",
			"    // 全要素をaで埋める．O(N).",
			"    void fill(T a = 0) {",
			"        std::fill(tree.begin() + 1, tree.end(), a);",
			"        if(a == 0) return;",
			"        build();",
			"    }",
			"    // k番目の要素にaを足す．O(logN).",
			"    void add(int k, T a) {",
			"        assert(1 <= k and k <= sz);",
			"        for(; k <= sz; k += (k & -k)) tree[k] += a;",
			"    }",
			"    // 区間[1,r]の総和を求める．O(logN).",
			"    T sum(int r) const {",
			"        assert(0 <= r and r <= sz);",
			"        T res = 0;",
			"        for(; r > 0; r -= (r & -r)) res += tree[r];",
			"        return res;",
			"    }",
			"    // 区間[l,r]の総和を求める．O(logN).",
			"    T sum(int l, int r) const {",
			"        assert(1 <= l and l <= r and r <= sz);",
			"        return sum(r) - sum(l - 1);",
			"    }",
			"};",
			""
		],
		"description": "Binary Indexed Tree"
	},
	"BIT0": {
		"scope": "cpp",
		"prefix": "BIT0",
		"body": [
			"// Binary Indexed Tree (0-based index).",
			"template <typename T>",
			"class BIT0 {",
			"    int sz;               // sz:=(要素数).",
			"    std::vector<T> tree;  // 0-based index.",
			"",
			"    void build() {",
			"        for(int i = 0; i < sz - 1; ++i) {",
			"            int j = i | (i + 1);",
			"            if(j < sz) tree[j] += tree[i];",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    BIT0() : BIT0(0){};",
			"    explicit BIT0(size_t sz_) : sz(sz_), tree(sz_, 0) {}",
			"    explicit BIT0(const std::vector<T> &v) : sz(v.size()), tree(v) {",
			"        build();",
			"    }",
			"",
			"    int size() const { return sz; }",
			"    // 全要素をaで埋める．O(N).",
			"    void fill(T a = 0) {",
			"        std::fill(tree.begin(), tree.end(), a);",
			"        if(a == 0) return;",
			"        build();",
			"    }",
			"    // k番目の要素にaを足す．O(logN).",
			"    void add(int k, T a) {",
			"        assert(0 <= k and k < sz);",
			"        for(; k < sz; k |= k + 1) tree[k] += a;",
			"    }",
			"    // 区間[0,r)の和を求める．O(logN).",
			"    T sum(int r) const {",
			"        assert(0 <= r and r <= sz);",
			"        T res = 0;",
			"        for(r = r - 1; r >= 0; r = (r & (r + 1)) - 1) res += tree[r];",
			"        return res;",
			"    }",
			"    // 区間[l,r)の和を求める．O(logN).",
			"    T sum(int l, int r) const {",
			"        assert(0 <= l and l <= r and r <= sz);",
			"        return sum(r) - sum(l);",
			"    }",
			"};"
		],
		"description": "Binary Indexed Tree (0-based index)"
	},
	"Combination": {
		"scope": "cpp",
		"prefix": "Combination",
		"body": [
			"// 二項係数（mod付き）．",
			"template <int mod>",
			"class Combination {",
			"    int sz;                       // sz:=(要素数). 制約は sz<=mod．",
			"    std::vector<long long> fact;  // fact[n]:=(nの階乗).",
			"    std::vector<long long> inv;   // inv[n]:=(nの逆元).",
			"    std::vector<long long> finv;  // finv[n]:=(nの階乗の逆元).",
			"",
			"    void build() {",
			"        fact[0] = fact[1] = 1;",
			"        inv[1] = 1;",
			"        finv[0] = finv[1] = 1;",
			"        for(int n = 2; n < sz; ++n) {",
			"            fact[n] = fact[n - 1] * n % mod;",
			"            inv[n] = mod - inv[mod % n] * (mod / n) % mod;",
			"            finv[n] = finv[n - 1] * inv[n] % mod;",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    Combination() : Combination(51e4) {}",
			"    explicit Combination(size_t sz_) : sz(sz_), fact(sz_), inv(sz_), finv(sz_) {",
			"        static_assert(mod >= 1);",
			"        assert(2 <= sz and sz <= mod);",
			"        build();",
			"    }",
			"",
			"    static constexpr int modulus() { return mod; }",
			"    // 階乗．",
			"    long long factorial(int n) const {",
			"        assert(0 <= n and n < sz);",
			"        return fact[n];",
			"    }",
			"    // 逆元．",
			"    long long inverse(int n) const {",
			"        assert(1 <= n and n < sz);",
			"        return inv[n];",
			"    }",
			"    // 階乗の逆元．",
			"    long long inverse_fact(int n) const {",
			"        assert(0 <= n and n < sz);",
			"        return finv[n];",
			"    }",
			"    // 順列．",
			"    long long nPk(int n, int k) const {",
			"        assert(0 <= k and k <= n and n < sz);",
			"        return fact[n] * finv[n - k] % mod;",
			"    }",
			"    // 組み合わせ．",
			"    long long nCk(int n, int k) const {",
			"        assert(0 <= k and k <= n and n < sz);",
			"        return fact[n] * finv[n - k] % mod * finv[k] % mod;",
			"    }",
			"    // 重複組み合わせ．",
			"    long long nHk(int n, int k) const { return nCk(k + n - 1, n - 1); }",
			"};",
			"",
			"using Combination998244353  = Combination<998'244'353>;",
			"using Combination1000000007 = Combination<1'000'000'007>;"
		],
		"description": "二項係数（mod付き）"
	},
	"Dijkstra": {
		"scope": "cpp",
		"prefix": "Dijkstra",
		"body": [
			"template <typename T>",
			"class Dijkstra {",
			"    template <typename Type>",
			"    using r_priority_queue = std::priority_queue<Type, std::vector<Type>, std::greater<Type> >;",
			"    struct Edge {",
			"        int to;",
			"        T cost;",
			"    };",
			"",
			"    int m_vn;                             // m_vn:=(ノード数).",
			"    std::vector<std::vector<Edge> > m_g;  // m_g[v][]:=(ノードvが始点である有向辺のリスト).",
			"    std::vector<T> m_d;                   // m_d[t]:=(ノードsからtへの最短距離).",
			"    std::vector<int> m_pre;               // m_pre[t]:=(ノードtを訪問する直前のノード番号). 逆方向経路．",
			"    T m_inf;",
			"",
			"public:",
			"    // constructor.",
			"    Dijkstra() : Dijkstra(0) {}",
			"    explicit Dijkstra(size_t vn, T inf = 1e9) : m_vn(vn), m_g(vn), m_d(vn, inf), m_pre(vn, -1), m_inf(inf) {}",
			"",
			"    // ノード数を返す．",
			"    int size() const { return m_vn; }",
			"    T infinity() const { return m_inf; }",
			"    // 重み付き有向辺を張る．",
			"    void add_edge(int from, int to, T cost) {",
			"        assert(0 <= from and from < m_vn);",
			"        assert(0 <= to and to < m_vn);",
			"        m_g[from].push_back((Edge){to, cost});",
			"    }",
			"    // ノードsから各ノードへの最短距離を求める．O(|E|*log|V|).",
			"    void dijkstra(int s) {",
			"        assert(0 <= s and s < m_vn);",
			"        std::fill(m_d.begin(), m_d.end(), m_inf);",
			"        m_d[s] = 0;",
			"        std::fill(m_pre.begin(), m_pre.end(), -1);",
			"        r_priority_queue<std::pair<T, int> > pque;",
			"        pque.emplace(0, s);",
			"        while(!pque.empty()) {",
			"            auto [dist, v] = pque.top();",
			"            pque.pop();",
			"            if(m_d[v] < dist) continue;",
			"            for(const Edge &e : m_g[v]) {",
			"                if(m_d[e.to] > m_d[v] + e.cost) {",
			"                    m_d[e.to] = m_d[v] + e.cost;",
			"                    m_pre[e.to] = v;",
			"                    pque.emplace(m_d[e.to], e.to);",
			"                }",
			"            }",
			"        }",
			"    }",
			"    // ノードsからtへの最短距離を返す．",
			"    T distance(int t) const {",
			"        assert(0 <= t and t < m_vn);",
			"        return m_d[t];",
			"    }",
			"    // ノードsからtへの最短経路を復元する．",
			"    std::vector<int> get_path(int t) const {",
			"        assert(0 <= t and t < m_vn);",
			"        std::vector<int> path;",
			"        for(; t != -1; t = m_pre[t]) path.push_back(t);",
			"        std::reverse(path.begin(), path.end());",
			"        return path;",
			"    }",
			"};"
		],
		"description": "単一始点最短経路問題"
	},
	"DynamicModint": {
		"scope": "cpp",
		"prefix": "DynamicModint",
		"body": [
			"template <int id>",
			"class DynamicModint {",
			"    static int mod;",
			"    long long val;",
			"",
			"public:",
			"    // constructor.",
			"    DynamicModint() : DynamicModint(0) {}",
			"    DynamicModint(long long val_) : val(val_) {",
			"        assert(mod >= 1);",
			"        val %= mod;",
			"        if(val < 0) val += mod;",
			"    }",
			"",
			"    DynamicModint operator+() const { return DynamicModint(*this); }",
			"    DynamicModint operator-() const { return DynamicModint(0) - (*this); }",
			"    DynamicModint &operator++() {",
			"        val++;",
			"        if(val == mod) val = 0;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator--() {",
			"        if(val == 0) val = mod;",
			"        val--;",
			"        return *this;",
			"    }",
			"    DynamicModint operator++(int) {",
			"        DynamicModint res = *this;",
			"        ++(*this);",
			"        return res;",
			"    }",
			"    DynamicModint operator--(int) {",
			"        DynamicModint res = *this;",
			"        --(*this);",
			"        return res;",
			"    }",
			"    DynamicModint &operator+=(const DynamicModint &a) {",
			"        val += a.val;",
			"        if(val >= mod) val -= mod;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator-=(const DynamicModint &a) {",
			"        val -= a.val;",
			"        if(val < 0) val += mod;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator*=(const DynamicModint &a) {",
			"        val = val * a.val % mod;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator/=(const DynamicModint &a) { return (*this) *= a.inv(); }",
			"",
			"    friend DynamicModint operator+(const DynamicModint &x, const DynamicModint &y) { return DynamicModint(x) += y; }",
			"    friend DynamicModint operator-(const DynamicModint &x, const DynamicModint &y) { return DynamicModint(x) -= y; }",
			"    friend DynamicModint operator*(const DynamicModint &x, const DynamicModint &y) { return DynamicModint(x) *= y; }",
			"    friend DynamicModint operator/(const DynamicModint &x, const DynamicModint &y) { return DynamicModint(x) /= y; }",
			"    friend bool operator==(const DynamicModint &x, const DynamicModint &y) { return x.val == y.val; }",
			"    friend bool operator!=(const DynamicModint &x, const DynamicModint &y) { return x.val != y.val; }",
			"    friend std::istream &operator>>(std::istream &is, DynamicModint &x) {",
			"        is >> x.val;",
			"        x.val %= mod;",
			"        if(x.val < 0) x.val += mod;",
			"        return is;",
			"    }",
			"    friend std::ostream &operator<<(std::ostream &os, const DynamicModint &x) { return os << x.val; }",
			"",
			"    static constexpr int get_id() { return id; }",
			"    static void set_modulus(int mod_) {",
			"        assert(mod_ >= 1);",
			"        mod = mod_;",
			"    }",
			"    static int modulus() { return mod; }",
			"    long long value() const { return val; }",
			"    DynamicModint inv() const {",
			"        long long a = val, b = mod, u = 1, v = 0;",
			"        while(b) {",
			"            long long t = a / b;",
			"            a -= t * b, u -= t * v;",
			"            std::swap(a, b), std::swap(u, v);",
			"        }",
			"        return DynamicModint(u);",
			"    }",
			"",
			"    friend DynamicModint mod_pow(const DynamicModint &x, long long k) {",
			"        if(k < 0) return mod_pow(x.inv(), -k);",
			"        DynamicModint res = 1, tmp = x;",
			"        while(k > 0) {",
			"            if(k & 1LL) res *= tmp;",
			"            tmp = tmp * tmp;",
			"            k >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"};",
			"",
			"template <int id>",
			"int DynamicModint<id>::mod = 1'000'000'007;"
		],
		"description": ""
	},
	"Modint": {
		"scope": "cpp",
		"prefix": "Modint",
		"body": [
			"template <int mod>",
			"class Modint {",
			"    long long val;",
			"",
			"public:",
			"    // constructor.",
			"    Modint() : Modint(0) {}",
			"    Modint(long long val_) : val(val_) {",
			"        static_assert(mod >= 1);",
			"        if(!(0 <= val and val < mod)) {",
			"            val %= mod;",
			"            if(val < 0) val += mod;",
			"        }",
			"    }",
			"",
			"    Modint operator+() const { return Modint(*this); }",
			"    Modint operator-() const { return Modint(0) - (*this); }",
			"    Modint &operator++() {",
			"        val++;",
			"        if(val == mod) val = 0;",
			"        return *this;",
			"    }",
			"    Modint &operator--() {",
			"        if(val == 0) val = mod;",
			"        val--;",
			"        return *this;",
			"    }",
			"    Modint operator++(int) {",
			"        Modint res = *this;",
			"        ++(*this);",
			"        return res;",
			"    }",
			"    Modint operator--(int) {",
			"        Modint res = *this;",
			"        --(*this);",
			"        return res;",
			"    }",
			"    Modint &operator+=(const Modint &a) {",
			"        val += a.val;",
			"        if(val >= mod) val -= mod;",
			"        return *this;",
			"    }",
			"    Modint &operator-=(const Modint &a) {",
			"        val -= a.val;",
			"        if(val < 0) val += mod;",
			"        return *this;",
			"    }",
			"    Modint &operator*=(const Modint &a) {",
			"        val = val * a.val % mod;",
			"        return *this;",
			"    }",
			"    Modint &operator/=(const Modint &a) { return (*this) *= a.inv(); }",
			"",
			"    friend Modint operator+(const Modint &x, const Modint &y) { return Modint(x) += y; }",
			"    friend Modint operator-(const Modint &x, const Modint &y) { return Modint(x) -= y; }",
			"    friend Modint operator*(const Modint &x, const Modint &y) { return Modint(x) *= y; }",
			"    friend Modint operator/(const Modint &x, const Modint &y) { return Modint(x) /= y; }",
			"    friend bool operator==(const Modint &x, const Modint &y) { return x.val == y.val; }",
			"    friend bool operator!=(const Modint &x, const Modint &y) { return x.val != y.val; }",
			"    friend std::istream &operator>>(std::istream &is, Modint &x) {",
			"        is >> x.val;",
			"        x.val %= mod;",
			"        if(x.val < 0) x.val += mod;",
			"        return is;",
			"    }",
			"    friend std::ostream &operator<<(std::ostream &os, const Modint &x) { return os << x.val; }",
			"",
			"    static constexpr int modulus() { return mod; }",
			"    long long value() const { return val; }",
			"    Modint inv() const {",
			"        long long a = val, b = mod, u = 1, v = 0;",
			"        while(b) {",
			"            long long t = a / b;",
			"            a -= t * b, u -= t * v;",
			"            std::swap(a, b), std::swap(u, v);",
			"        }",
			"        return Modint(u);",
			"    }",
			"",
			"    friend Modint mod_pow(const Modint &x, long long k) {",
			"        if(k < 0) return mod_pow(x.inv(), -k);",
			"        Modint res = 1, tmp = x;",
			"        while(k > 0) {",
			"            if(k & 1LL) res *= tmp;",
			"            tmp = tmp * tmp;",
			"            k >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"};",
			"",
			"using mint998244353  = Modint<998'244'353>;",
			"using mint1000000007 = Modint<1'000'000'007>;"
		],
		"description": ""
	},
	"Montmort": {
		"scope": "cpp",
		"prefix": "Montmort",
		"body": [
			"// 完全順列（mod付き）．",
			"template <int mod>",
			"class Montmort {",
			"    int m_sz;",
			"    std::vector<long long> m_a;  // m_a[k]:=(k番目のモンモール数).",
			"",
			"public:",
			"    Montmort() : Montmort(51e4) {}",
			"    explicit Montmort(size_t sz) : m_sz(sz), m_a(sz) {",
			"        static_assert(mod >= 1);",
			"        assert(m_sz >= 2);",
			"        m_a[0] = 1, m_a[1] = 0;",
			"        for(int i = 2; i < m_sz; ++i) m_a[i] = (i - 1) * ((m_a[i - 2] + m_a[i - 1]) % mod) % mod;  // 隣接三項間の漸化式．",
			"        // for(int i = 2; i < m_sz; ++i) m_a[i] = (i * m_a[i - 1] % mod + (i & 1 ? -1 : 1) + mod) % mod;  // 隣接二項間の漸化式．",
			"    }",
			"",
			"    static constexpr int modulus() { return mod; }",
			"    // k個の要素を並び替えたときに完全順列となる通り数．",
			"    long long montmort(int k) const {",
			"        assert(1 <= k and k < m_sz);",
			"        return m_a[k];",
			"    }",
			"    // 無限個の要素を並び替えたときに完全順列となる確率．",
			"    static constexpr double convergence_probability() { return 1.0 / std::exp(1.0); }",
			"};"
		],
		"description": "完全順列（mod付き）"
	},
	"Sieve": {
		"scope": "cpp",
		"prefix": "Sieve",
		"body": [
			"// エラトステネスの篩．",
			"class Sieve {",
			"    int m_mx;                // m_mx:=(篩にかける最大の自然数).",
			"    std::vector<int> m_lpf;  // m_lpf[n]:=(自然数nの最小の素因数). Least prime factor. m_lpf[n]==n のとき，nは素数．",
			"",
			"    int internal_pow(int n, unsigned int k) const {",
			"        if(k == 0) return 1;",
			"        auto &&res = internal_pow(n * n, k >> 1);",
			"        if(k & 1U) res *= n;",
			"        return res;",
			"    }",
			"",
			"public:",
			"    // constructor. mx以下の自然数を篩にかける．O(N*loglogN).",
			"    Sieve() : Sieve(51e4) {}",
			"    explicit Sieve(int mx) : m_mx(mx), m_lpf(mx + 1, -1) {",
			"        assert(mx >= 0);",
			"        for(int p = 2; p <= m_mx; ++p) m_lpf[p] = p;",
			"        for(int p = 2; p * p <= m_mx; ++p) {",
			"            if(m_lpf[p] == p) {",
			"                for(int n = p * p; n <= m_mx; n += p) {",
			"                    if(m_lpf[n] == n) m_lpf[n] = p;",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    // 素数判定．O(1).",
			"    bool is_prime(int n) const {",
			"        assert(0 <= n and n <= m_mx);",
			"        return m_lpf[n] == n;",
			"    }",
			"    // 自然数nの最小の素因数を返す．O(1).",
			"    int get_lpf(int n) const {",
			"        assert(0 <= n and n <= m_mx);",
			"        return m_lpf[n];",
			"    }",
			"    // 高速素因数分解．O(logN).",
			"    std::map<int, int> prime_factorize(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        std::map<int, int> res;",
			"        while(n > 1) {",
			"            res[m_lpf[n]]++;",
			"            n /= m_lpf[n];",
			"        }",
			"        return res;",
			"    }",
			"    // 高速約数列挙．",
			"    std::vector<int> divisors(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        std::vector<int> res({1});",
			"        const auto &&pf = prime_factorize(n);",
			"        for(const auto &[p, cnt] : pf) {",
			"            const int sz = res.size();",
			"            int b = 1;",
			"            for(int i = 0; i < cnt; ++i) {",
			"                b *= p;",
			"                for(int j = 0; j < sz; ++j) res.push_back(res[i] * b);",
			"            }",
			"        }",
			"        std::sort(res.begin(), res.end());",
			"        return res;",
			"    }",
			"    // オイラーのファイ関数．n以下でnと互いに素な自然数の個数．",
			"    int totient(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        const auto &&pf = prime_factorize(n);",
			"        int res = 1;",
			"        for(const auto &[p, cnt] : pf) res *= internal_pow(p, cnt - 1) * (p - 1);",
			"        return res;",
			"    }",
			"};"
		],
		"description": "エラトステネスの篩"
	},
	"UnionFind": {
		"scope": "cpp",
		"prefix": "UnionFind",
		"body": [
			"// 素集合データ構造．",
			"class UnionFind {",
			"    int m_vn;                // m_vn:=(ノード数).",
			"    int m_gn;                // m_gn:=(グループ数).",
			"    std::vector<int> m_par;  // m_par[v]:=(ノードvの親番号). 0未満の場合，vは親で，値の絶対値はグループサイズを表す．",
			"",
			"public:",
			"    // constructor.",
			"    UnionFind() : UnionFind(0) {}",
			"    explicit UnionFind(size_t vn) : m_vn(vn), m_gn(vn), m_par(vn, -1) {}",
			"",
			"    // ノード数を返す．",
			"    int get_vn() const { return m_vn; };",
			"    // グループ数を返す．",
			"    int get_gn() const { return m_gn; };",
			"    // ノードvの親番号を返す．",
			"    int root(int v) {",
			"        assert(0 <= v and v < m_vn);",
			"        if(m_par[v] < 0) return v;",
			"        return m_par[v] = root(m_par[v]);",
			"    }",
			"    // ノードvが属するグループのサイズを返す．",
			"    int size(int v) {",
			"        assert(0 <= v and v < m_vn);",
			"        return -m_par[root(v)];",
			"    }",
			"    // ノードuとvが同じグループか判定する．",
			"    bool same(int u, int v) {",
			"        assert(0 <= u and u < m_vn);",
			"        assert(0 <= v and v < m_vn);",
			"        return root(u) == root(v);",
			"    }",
			"    // ノードu, vが属するそれぞれのグループを結合する．",
			"    bool unite(int u, int v) {",
			"        assert(0 <= u and u < m_vn);",
			"        assert(0 <= v and v < m_vn);",
			"        u = root(u), v = root(v);",
			"        if(u == v) return false;                // Do nothing.",
			"        if(size(u) < size(v)) std::swap(u, v);  // Merge technique.",
			"        m_par[u] += m_par[v];",
			"        m_par[v] = u;",
			"        m_gn--;",
			"        return true;",
			"    }",
			"    void reset() {",
			"        m_gn = m_vn;",
			"        std::fill(m_par.begin(), m_par.end(), -1);",
			"    }",
			"};"
		],
		"description": "素集合データ構造"
	},
	"bit_count": {
		"scope": "cpp",
		"prefix": "bit_count",
		"body": [
			"int bit_count32(uint32_t n) {",
			"    const uint32_t masks[5] = {0x55555555U, 0x33333333U, 0x0f0f0f0fU, 0x00ff00ffU, 0x0000ffffU};",
			"    for(int i = 0; i < 5; ++i) n = (n & masks[i]) + ((n >> (1U << i)) & masks[i]);",
			"    return n;",
			"}",
			"",
			"int bit_count64(uint64_t n) {",
			"    const uint64_t masks[6] = {0x5555555555555555ULL, 0x3333333333333333ULL, 0x0f0f0f0f0f0f0f0fULL,",
			"                               0x00ff00ff00ff00ffULL, 0x0000ffff0000ffffULL, 0x00000000ffffffffULL};",
			"    for(int i = 0; i < 6; ++i) n = (n & masks[i]) + ((n >> (1ULL << i)) & masks[i]);",
			"    return n;",
			"}"
		],
		"description": "ビットカウント"
	},
	"chmin, chmax": {
		"scope": "cpp",
		"prefix": "chmin, chmax",
		"body": [
			"template<typename Type> inline bool chmin(Type &a,const Type &b){if(a>b){a=b;return true;}return false;}",
			"template<typename Type> inline bool chmax(Type &a,const Type &b){if(a<b){a=b;return true;}return false;}"
		],
		"description": ""
	},
	"chtoupper, chtolower": {
		"scope": "cpp",
		"prefix": "chtoupper, chtolower",
		"body": [
			"inline bool chtoupper(char &c){if('a'<=c && c<='z'){c-=0x20;return true;}return false;}",
			"inline bool chtolower(char &c){if('A'<=c && c<='Z'){c+=0x20;return true;}return false;}"
		],
		"description": ""
	},
	"compress": {
		"scope": "cpp",
		"prefix": "compress",
		"body": [
			"// 座標圧縮．",
			"template <typename Type>",
			"std::vector<Type> compress(std::vector<Type> &v) {",
			"    const int n = v.size();",
			"    std::vector<Type> res = v;",
			"    std::sort(res.begin(), res.end());",
			"    res.erase(std::unique(res.begin(), res.end()), res.end());",
			"    for(int i = 0; i < n; ++i) v[i] = std::lower_bound(res.begin(), res.end(), v[i]) - res.begin();",
			"    return res;",
			"}"
		],
		"description": "座標圧縮"
	},
	"split": {
		"scope": "cpp",
		"prefix": "split",
		"body": [
			"// 文字列分割．指定の文字delimで分割する．",
			"std::vector<std::string> split(const std::string &s, char delim) {",
			"    std::vector<std::string> res;",
			"    std::stringstream ss(s);",
			"    std::string item;",
			"    while(std::getline(ss, item, delim)) {",
			"        if(!item.empty()) res.push_back(item);",
			"    }",
			"    return res;",
			"}"
		],
		"description": "文字列分割"
	},
	"stov, vtos": {
		"scope": "cpp",
		"prefix": "stov, vtos",
		"body": [
			"std::vector<int> stov(const std::string &s) {",
			"    const int n = s.size();",
			"    std::vector<int> v(n);",
			"    for(int i = 0; i < n; ++i) v[i] = s[i];",
			"    return v;",
			"}",
			"",
			"std::string vtos(const std::vector<int> &v) {",
			"    const int n = v.size();",
			"    std::string s(n, 0);",
			"    for(int i = 0; i < n; ++i) {",
			"        assert(0 <= v[i] and v[i] < 128);",
			"        s[i] = v[i];",
			"    }",
			"    return s;",
			"}"
		],
		"description": ""
	},
	"table": {
		"scope": "cpp",
		"prefix": "table",
		"body": [
			"template <typename Type>",
			"std::vector<Type> table(size_t n, Type val) { return std::vector<Type>(n, val); }",
			"",
			"template <class... Args>",
			"auto table(size_t n, Args &&...args) {",
			"    auto val = table(std::forward<Args>(args)...);",
			"    return std::vector<decltype(val)>(n, std::move(val));",
			"}"
		],
		"description": "多次元配列生成"
	},
	"z_algorithm": {
		"scope": "cpp",
		"prefix": "z_algorithm",
		"body": [
			"// 最長共通接頭辞 (LCP:Longest Common Prefix)．O(|S|).",
			"template <class Class>",
			"std::vector<int> z_algorithm(const Class &s) {",
			"    const int n = s.size();",
			"    std::vector<int> z(n);  // z[i]:=(sとs[i:]のLCPの長さ).",
			"    z[0] = n;",
			"    int i = 1, j = 0;",
			"    while(i < n) {",
			"        while(i + j < n and s[j] == s[i + j]) j++;",
			"        z[i] = j;",
			"        if(j == 0) {",
			"            i++;",
			"            continue;",
			"        }",
			"        int k = 1;",
			"        while(i + k < n and z[k] + k < j) {",
			"            z[i + k] = z[k];",
			"            k++;",
			"        }",
			"        i += k, j -= k;",
			"    }",
			"    return z;",
			"}"
		],
		"description": "最長共通接頭辞 (LCP:Longest Common Prefix)"
	}
}